#!/usr/bin/env python3
from http.server import HTTPServer, BaseHTTPRequestHandler
import json
import time
import subprocess

class BullshitError(Exception):
    pass
class Job:
    def __init__(self, job_spec, jobid):
        self.running = False
        self.jobid = jobid
        self.process = None
        self.job_spec = job_spec
    def start(self):
        try:
            self.process = subprocess.Popen(self.job_spec.script)
        except Exception as e:
            print(f"OOPSIE POOPSIE: {e}")
            return False
        return True
    def __str__(self):
        pid = self.process.pid if self.process else None
        return f"JOBID: {self.jobid}, PID: {pid}, SCRIPT: {self.job_spec.script}"

class JobSpec:
    def __init__(self, script, **kwargs):
        self.script = script
        self.kwargs = kwargs

class Scheduler:
    jobid_counter = 0
    def __init__(self):
        self.queue = []
        self.running_jobs = []
        self.current_job = None
    def submit(self, job_spec):
        self.jobid_counter += 1
        new_job = Job(job_spec, self.jobid_counter)
        self.queue.append(new_job)
        return new_job
    def delete(self, job_id):
        pass
    def schedule(self):
        if self.current_job is None:
            if self.queue:
                self.current_job = self.queue.pop(0)
                print(f"==== Starting job {self.current_job}")
                if not self.current_job.start():
                    self.current_job = None
        else:
            poll = self.current_job.process.poll()
            if poll is None:
                # print(f" Job with id {self.current_job.jobid}, pid {self.current_job.process.pid} IS RUNNING")
                pass
            else:
                # print(f" Job ended ")
                print(f"==== Job {self.current_job} finished")
                self.current_job = None

class APIHandler(BaseHTTPRequestHandler):
    def do_POST(self):
        if self.path == '/submit':
            self.handle_submit()
        elif self.path == '/delete':
            self.handle_delete()
        elif self.path == '/status':
            self.handle_status()
        elif self.path == '/fruits':
            self.send_response(200)
            self.send_header('Content-Type', 'application/json')
            self.end_headers()
            fruits = ['apple', 'banana', 'mango']
            self.wfile.write(json.dumps(fruits).encode())
        else:
            print(self)
            self.send_response(200)
            self.send_header('Content-Type', 'application/json')
            self.end_headers()
            self.wfile.write(json.dumps({'hello':'world', 'number': 8}, indent=4).encode() + b'\n')
    def get_request_body_json(self):
        content_length = int(self.headers['Content-Length'])
        return json.loads(self.rfile.read(content_length))
    def handle_submit(self):
        request_body = self.get_request_body_json()
        new_job = SCHEDULER.submit(JobSpec(script=request_body['script']))
        output = f"Jobid is {new_job.jobid}".encode()

        # NOTE: self.send_response() needs to come before starting
        # to set the headers.  Otherwise, we end up with an invalid HTTP
        # response to which cURL will say
        #      curl: (1) Received HTTP/0.9 when not allowed
        # and exit with an error code of 1.
        # I wasted about 30 minutes searching for how to set the protocol
        # for the response to 'not 0.9' only to find out that it was already
        # not 0.9 and more googling to find out that this cURL message could
        # be due to malformed HTTP response, at which point I tried random
        # changes until I moved the send_response call to the top
        self.send_response(200)
        self.send_header('Content-Type', 'application/text')
        # self.send_header('Content-Length', str(len(output)))
        self.end_headers()
        self.wfile.write(output)



SCHEDULER = Scheduler()
handler = APIHandler
httpd = HTTPServer(('localhost', 8080), handler)
httpd.timeout = 1
while True:
    httpd.handle_request()
    SCHEDULER.schedule()
    time.sleep(1)
